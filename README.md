## gRPC Performance for Inter-Service Communication

### Overview

**gRPC** is used as a mechanism for transmitting large arrays of geopoints from **Service 1 (Client)** to **Service 2 (Server)**. This section details the setup, configuration, and performance metrics specifically for gRPC.

### Key Technologies

- **gRPC**: An efficient RPC framework that uses HTTP/2 for transport, allowing for lower latency and better performance compared to traditional REST APIs.
- **MongoDB**: The database where the geopoints are stored.
- **Node.js**: The backend framework for implementing both services.

### gRPC Setup Instructions

#### Prerequisites

- Node.js v16+
- MongoDB installed and running
- gRPC dependencies installed (ensure you have `@grpc/grpc-js` and `@grpc/proto-loader` in your package.json)

#### Installation

1. Clone the repository:

   ```bash
   git clone <repository-url>
   cd <project-directory>
   ```

2. Install dependencies:

   ```bash
   npm install
   ```

3. Start MongoDB locally or provide connection details.

#### Configuration

- The gRPC settings are defined in the **Service 2 (Server)** directory. Adjust the MongoDB URI and gRPC host settings in the `.env` file as needed.

### Running the gRPC Services

1. Start **Service 2 (Server)** with gRPC mode:

   ```bash
   cd service-2
   npm run grpc
   ```

2. Start **Service 1 (Client)**, ensuring the communication mode is set to gRPC by updating the `.env` file:

   ```
   MODE=grpc
   ```

   Then, run:

   ```bash
   cd service-1
   npm start
   ```

### Performance Metrics for gRPC

| Metric          | Description                                                                                                                                |
| --------------- | ------------------------------------------------------------------------------------------------------------------------------------------ |
| **Latency**     | Lower latency due to real-time communication and smaller overhead in transmitting messages compared to Kafka.                              |
| **Throughput**  | While gRPC handles smaller payloads efficiently, it may struggle with larger payloads compared to Kafka, especially under high load.       |
| **Reliability** | Provides lower reliability in case of network failures. However, this can be mitigated with retry mechanisms in the client implementation. |
| **Data Size**   | gRPC performs optimally for moderate data sizes. Performance can decrease with very large payloads due to serialization overhead.          |

### Results

- **Latency**: gRPC demonstrated faster response times for smaller sets of geopoints, making it ideal for real-time applications where immediate feedback is required.
- **Throughput**: For moderate-sized payloads, gRPC handled the data transfer smoothly, but as the size increased, the throughput decreased compared to Kafka.

### Conclusion

- **gRPC** is excellent for low-latency, real-time communication, especially in scenarios where response time is critical. However, for very large datasets, it may not match the throughput capabilities of Kafka.

### How to Test with gRPC

1. In **Service 1 (Client)**, ensure the communication mode is set to gRPC:

   ```
   MODE=grpc
   ```

2. Start **Service 2 (Server)** in gRPC mode:

   ```bash
   cd service-2
   npm run grpc
   ```

3. Start **Service 1 (Client)**:

   ```bash
   cd service-1
   npm start
   ```

### Monitoring Performance

Monitor the logs generated by both services to track the time taken for data transmission and successful storage in MongoDB. Measuring memory usage and CPU performance will also help evaluate the efficiency of the gRPC implementation.

---

Feel free to customize any part of this section according to your project requirements!
